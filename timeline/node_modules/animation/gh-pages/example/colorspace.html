<html>
<head>
    <title>24h color clock delux</title>
</head>
<body id="body">
    <div id="txt" style="opacity:0.4;font-size:44pt"></div>
    <pre id="colors" style="opacity:0.4;font-size:44pt"></pre>
</body>
<script src="../animation.browser.js"></script>
<script>

function pad(s, h, l) {
    s = "" + s;
    if (s.length >= l) return s;
    return new Array(l - s.length + 1).join(""+h) + s;
}

// x, y, z, r, g, b, h, s, l are all in the range [0,1]

function mul(col, n) {
    var c = {};
    for (var k in col)
        c[k] = col[k] * n;
    return c;
}

function norm(col, n) {
    return mul(col, 1/n);
}

function xyz2rgb(c) {
    var r = {
        r:c.x *  3.2406 + c.y * -1.5372 + c.z * -0.4986,
        g:c.x * -0.9689 + c.y *  1.8758 + c.z *  0.0415,
        b:c.x *  0.0557 + c.y * -0.2040 + c.z *  1.0570
    };
    var _proc = 1 / 2.4;
    for (var k in r) {
        if ( r[k] > 0.0031308 )
            r[k] = 1.055 * Math.pow( r[k], _proc ) - 0.055;
        else
            r[k] = 12.92 * r[k];
    }
    return r;
}

function rgb2xyz(col) {
    var c = {};
    var _proc = 1 / 1.055;
    for (var k in col) {
        c[k] = col[k];
        if ( c[k] > 0.04045 )
            c[k] = Math.pow( ( c[k] + 0.055 ) * _proc, 2.4);
        else
            c[k] /= 12.92;
    }
    return {
        x: c.r * 0.4124 + c.g * 0.3576 + c.b * 0.1805,
        y: c.r * 0.2126 + c.g * 0.7152 + c.b * 0.0722,
        z: c.r * 0.0193 + c.g * 0.1192 + c.b * 0.9505
    };
}

function rgb2hsl(col) {
    var max = Math.max(col.r,col.g,col.b), min = Math.min(col.r,col.g,col.b);
    var c = {h:0, s:0, l:(max + min) / 2};

    if (max == min)
        return c; // achromatic
    var d = max - min;
    c.s = c.l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
        case col.r: c.h = (col.g - col.b) / d + (col.g < col.b ? 6 : 0); break;
        case col.g: c.h = (col.b - col.r) / d + 2; break;
        case col.b: c.h = (col.r - col.g) / d + 4; break;
    }
    c.h /= 6;
    // hue is an angle
    while (c.h > 1) c.h--;
    while (c.h < 0) c.h++;

    return c;
}

function hsl2rgb(col) {
    var c = {r:col.l, g:col.l, b:col.l};
    if (col.s == 0)
        return c; // achromatic
    var m2 = col.l > 0.5 ? col.l + col.s - col.l * col.s
           :               col.l * (col.s + 1);
    var m1 = col.l * 2 - m2;
    var n = -1;
    for(var k in c) {
        var h = col.h + n / 3;
        while (h > 1) h--;
        while (h < 0) h++;

        c[k] = 6 * h < 1 ? m1 + (m2 - m1) * h * 6
             : 2 * h < 1 ? m2
             : 3 * h < 2 ? m1 + (m2 - m1) * (2/3 - h) * 6
             :             m1;
        n++;
    }
    return c;
}

function xyz2uv(col) {
    var _proc = 1 / (col.x + 15 * col.y + 3 * col.z);
    return {
        u: 4 * col.x * _proc,
        v: 6 * col.y * _proc
    };
}

function uv2xy(c) {
    var _proc = 1 / (2 * c.u - 8 * c.v + 4);
    return {
        x: 3 * c.u * _proc,
        y: 2 * c.v * _proc
    };
}

function CIEtransform(c) { // light matrix
    var _proc = 1 / 0.17697;
    return {
        x: _proc * (c.r * 0.489921 + c.g * 0.310016 + c.b * 0.200063),
        y: _proc * (c.r * 0.176937 + c.g * 0.812422 + c.b * 0.010641),
        z: _proc * (c.r * 0.000000 + c.g * 0.009999 + c.b * 0.990301)
    };
}

function luminate(c, V) { // V is the lumitance of the stimulus
    var _L = 1 / (c.x + c.y + c.z);
    var l = {};
    for (var k in c)
        l[k] = c[k] * _L;
    var _proc = 1 / l.y;
    return {
        x: V * l.x * _proc,
        y: V,
        z: V * l.z * _proc
    };
}

function spectralRadiance(w, T) { // w = wavelength in nm
    // returns  the black body spectral radiance (power per unit area per unit solid angle per unit wavelength)
    var h = 4.13566751691 * Math.pow(10,-15); // Planck constant in eV
    var k = 8.61733247878 * Math.pow(10, -5); // Boltzmann constant in eV
    var c = 299792458     * Math.pow(10,  9); // speed of light in nm/s
    return ((2*Math.PI*h*c*c)/Math.pow(w,5))/(Math.exp(((h*c)/w)/(k*T))-1);
}

function planckianLocus(c, l, T) {
    return {
        x: c.x * spectralRadiance(l.r, T),
        y: c.y * spectralRadiance(l.g, T),
        z: c.z * spectralRadiance(l.b, T)
    };
}

function interpolate(c1, c2, p) {
    var c = {};
    for (var k in c1)
        c[k] = c1[k]*(1-p) + c2[k]*p;
    return c;
}

var light = {
    "oled": { // in nm
        r:732, // 1.69eV
//         r:665, // 1.86eV
//         r:621, // 1.99eV
        g:492,
//         b:514 // 2.41eV
//         b:482 // 2.57eV
        b:456 // 2.72eV
    }
};

var whitepoint = {
    "E": { // Equal energy
        T: 5454, // in K
        // CIE 1931 2°
        x:1/3,
        y:1/3
        // CIE 1964 10°
//         x:1/3,
//         y:1/3
    },
    "D55": { // Mid-morning / Mid-afternoon Daylight
        T: 5503, // in K
        // CIE 1931 2°
        x:0.33242,
        y:0.34743
        // CIE 1964 10°
//         x:0.33411,
//         y:0.34877
    }
};


var rs2pi = 1 / Math.sqrt(2 * Math.PI);
function generateColor(t) {
    // nice_color = surface × lighting × simple_color
    return xyz2rgb(
        luminate(
            // optimize for black screen
            planckianLocus(
                // human gamut (nicer colors)
                CIEtransform(
                    // generate color
                    hsl2rgb({
                        // yellow → orange → red → violet → blue → green over 6h
                        h:(t % 6) / 6 + 2/3,
                        s:1.0,
                        l:0.5
                    })
                ), // TODO surface missing!
                light["oled"],
                whitepoint["E"].T
            )
        // night-day transition
        ,0.05 * // FIXME i guess this should be the surface
        rs2pi*(Math.exp((-1)*Math.pow((t-12),2)/Math.pow(7/*day light*/,2)))
        )
    );
}

function inbound(from, to, value) {
    return value < from ? from :
           value > to   ? to   :
                          value;
}

var sec = 0;
new Animation({frame:'60ms'}).on('tick', function (dt) {

    var t = sec/60/60; // sec as hours

    var c = generateColor(t);
//     var c = xyz2rgb(rgb2xyz(interpolate(c1, c2, p))); // workz!
//     var c = hsl2rgb(rgb2hsl(interpolate(c1, c2, p))); // workz!

    var body = document.getElementById('body');
    var txt = document.getElementById('txt');

    var rgb = "rgb("
            + Math.abs(Math.round(c.r * 255)) + ", "
            + Math.abs(Math.round(c.g * 255)) + ", "
            + Math.abs(Math.round(c.b * 255)) + ")";
//     console.log(t, rgb, tr)
//     console.log(new Array(Math.floor(Math.abs(c.r)*80)).join(" "),"r")
//     console.log(new Array(Math.floor(Math.abs(c.g)*80)).join(" "),"g")
//     console.log(new Array(Math.floor(Math.abs(c.b)*80)).join(" "),"b")
    body.style.backgroundColor = rgb;

    var d = new Date(sec*1000);
    txt.textContent = pad(d.getHours(),   "0", 2) + ":"
                    + pad(d.getMinutes(), "0", 2) + ":"
                    + pad(d.getSeconds(), "0", 2);

    var c = dt / this.frametime; // tick correction
    sec += 200 * c;
    if (t >= 24) sec -= 24*60*60; // overflow → repeat the loop
}).start();

// show precalculated colors
// r g b channels seperated and a value for each half an hour (48 values in sum)
(function () {
    var txt = document.getElementById('colors');

    var cs = {r:[], g:[], b:[]};
    for (var t = 0 ; t < 24 ; t += 0.5) {
        var c = generateColor(t);
        for (var k in c)
            cs[k].push(c[k]);
    }

    var s = "";
    console.log(cs.r.length, cs.g.length, cs.b.length);
    for(var k in cs)
        s += "{" + cs[k].map(function(x){return inbound(0,255,Math.abs(Math.round(255*x)))}).join(",") + "}"
          +  (k === "b" ? "" : "," )
          +  " // " + {r:"red", g:"green", b:"blue"}[k]
          + "\n";
    txt.textContent = s;

})()
</script>
</html>
